/* Generated by gep (125/04/14 21:47:43) copyright (c) 2008 IRIT - UPS */
#ifndef GLISS_AVR_INCLUDE_AVR_API_H
#define GLISS_AVR_INCLUDE_AVR_API_H

#include <stdint.h>
#include <stdio.h>

#if defined(__WIN32) || defined(__WIN64)
#	ifdef __cplusplus
#		define __BEGIN_DECLS	extern "C" {
#		define __END_DECLS		}
#	else
#		define __BEGIN_DECLS
#		define __END_DECLS
#	endif
#else
#	include <sys/cdefs.h>
#endif

#include "id.h"
#include "mem.h"
#include "decode.h"

__BEGIN_DECLS

#define AVR_PROC_NAME "AVR"
#define AVR_PC_NAME  PC

/* return an instruction identifier as a string instead of the avr_ident_t which is not very user friendly */
char *avr_get_string_ident(avr_ident_t id);

/* opaque types */
typedef struct avr_platform_t avr_platform_t;
typedef struct avr_fetch_t avr_fetch_t;
typedef struct avr_decoder_t avr_decoder_t;
struct avr_loader_t;
typedef struct mask_t mask_t;

/* avr_state_t type */
typedef struct avr_state_t {
	avr_platform_t *platform;
	uint8_t SKIP_NEXT;
	uint8_t SREG;
	uint8_t IO[64];
	uint16_t SP;
	uint8_t R[32];
	uint16_t PC;

	avr_memory_t *FLASH;
	avr_memory_t *M;

} avr_state_t;

/* avr_sim_t type */
typedef struct avr_sim_t {
	avr_state_t *state;
	avr_decoder_t *decoder;
	/* on libc stripped programs it is difficult to find the exit point, so we specify it */
	avr_address_t addr_exit;
	/* anything else? */
	int ended;
} avr_sim_t;


/* avr_value_t type */
typedef union avr_value_t {
	int8_t int8;
	uint8_t uint8;
	int16_t int16;
	uint16_t uint16;
	uint32_t uint32;

} avr_value_t;


/* avr_ii_t type */
typedef struct avr_ii_t {
	avr_value_t val;
} avr_ii_t;

/* avr_inst_t type */
typedef struct avr_inst_t {
	avr_ident_t   ident;
	avr_address_t addr;
	avr_ii_t instrinput[2];

} avr_inst_t;

/* auxiliary vector */
typedef struct avr_auxv_t {
	int	a_type;
	union {
		long a_val;
		void *a_ptr;
		void (*a_fcn)();
	} a_un;
} avr_auxv_t;

/* environment description */
typedef struct avr_env_t
{
	int argc;

	char **argv;
	avr_address_t argv_addr;

	char **envp;
	avr_address_t envp_addr;

	avr_auxv_t *auxv;
	avr_address_t auxv_addr;

	avr_address_t stack_pointer;
	avr_address_t brk_addr;
} avr_env_t;

/* platform management */
#define AVR_MAIN_MEMORY		0
avr_platform_t *avr_new_platform(void);
avr_memory_t *avr_get_memory(avr_platform_t *platform, int index);
struct avr_env_t;
struct avr_env_t *avr_get_sys_env(avr_platform_t *platform);
void avr_lock_platform(avr_platform_t *platform);
void avr_unlock_platform(avr_platform_t *platform);
int avr_load_platform(avr_platform_t *platform, const char *path);
void avr_load(avr_platform_t *platform, struct avr_loader_t *loader);

/* fetching */
avr_fetch_t *avr_new_fetch(avr_platform_t *pf);
void avr_delete_fetch(avr_fetch_t *fetch);


avr_ident_t avr_fetch(avr_fetch_t *fetch, avr_address_t address, mask_t *code);

/* decoding */
typedef struct avr_mode_t {
	const char *name;
	avr_inst_t *(*decode)(avr_decoder_t *decoder, avr_address_t address);
} avr_mode_t;
extern avr_mode_t avr_modes[];

avr_decoder_t *avr_new_decoder(avr_platform_t *pf);
void avr_delete_decoder(avr_decoder_t *decoder);
avr_inst_t *avr_decode(avr_decoder_t *decoder, avr_address_t address);
void avr_free_inst(avr_inst_t *inst);
void avr_set_cond_state(avr_decoder_t *decoder, avr_state_t *state);
unsigned long avr_get_inst_size(avr_inst_t* inst);
unsigned long avr_get_inst_size_from_id(avr_ident_t id);


/* code execution */
void avr_execute(avr_state_t *state, avr_inst_t *inst);

/* state management function */
avr_state_t *avr_new_state(avr_platform_t *platform);
void avr_delete_state(avr_state_t *state);
avr_state_t *avr_copy_state(avr_state_t *state);
avr_state_t *avr_fork_state(avr_state_t *state);
void avr_dump_state(avr_state_t *state, FILE *out);
void avr_output_header_valid(FILE *out);
void avr_output_state_valid(avr_state_t *state, FILE *out);
avr_platform_t *avr_platform(avr_state_t *state);

/* simulation functions */
avr_sim_t *avr_new_sim(avr_state_t *state, avr_address_t start_addr, avr_address_t exit_addr);
avr_inst_t *avr_next_inst(avr_sim_t *sim);
uint64_t avr_run_and_count_inst(avr_sim_t *sim);
void avr_run_sim(avr_sim_t *sim);
void avr_step(avr_sim_t *sim);
void avr_delete_sim(avr_sim_t *sim);
avr_address_t  avr_next_addr(avr_sim_t *sim);
void avr_set_next_address(avr_sim_t *sim, avr_address_t address);
#define avr_set_entry_address(sim, addr) avr_set_next_address(sim, addr)
void avr_set_exit_address(avr_sim_t *sim, avr_address_t address);
#define avr_set_sim_ended(sim) (sim)->ended = 1
#define avr_is_sim_ended(sim) ((sim)->ended)

/* disassemble function */
void avr_disasm(char *buffer, avr_inst_t *inst);
typedef char *(*avr_label_solver_t)(avr_address_t address);
extern avr_label_solver_t avr_solve_label;
char *avr_solve_label_null(avr_address_t address);

/* variable length functions */
uint32_t value_on_mask(mask_t *inst, mask_t *mask);

/* assertion management */
void avr_assert(avr_state_t *state, int c, const char *file, int line);
extern int avr_assert_enable;

__END_DECLS

#endif /* GLISS_AVR_INCLUDE_AVR_API_H */
