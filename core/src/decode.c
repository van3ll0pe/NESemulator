/* Generated by gep (125/04/14 21:47:45) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <avr/fetch.h>
#include <avr/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <avr/config.h> /* for memory endiannesses */
#include <avr/gen_int.h>
#include "decode_table.h"

#define avr_error(e) fprintf(stderr, "%s\n", (e))


/* external functions */
avr_ident_t avr_fetch(avr_fetch_t *fetch, avr_address_t address, mask_t *code);


/* external tables */

/* decode structure */
struct avr_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
	avr_fetch_t *fetch;
};

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
avr_inst_t *avr_decode(avr_decoder_t *decoder, avr_address_t address);


/* initialization and destruction of avr_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder(avr_decoder_t *d, avr_platform_t *pf)
{
d->fetch = avr_new_fetch(pf);
}

static void halt_decoder(avr_decoder_t *d)
{
        avr_delete_fetch(d->fetch);
     
}

avr_decoder_t *avr_new_decoder(avr_platform_t *pf) {
	assert(pf);
    avr_decoder_t *res = malloc(sizeof(avr_decoder_t));
    if (res == NULL)
                avr_error("not enough memory to create a avr_decoder_t object"); /* I assume error handling will remain the same, we use avr_error istead of iss_error ? */
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void avr_delete_decoder(avr_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                avr_error("cannot delete an NULL avr_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
    
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void avr_set_cond_state(avr_decoder_t *decoder, avr_state_t *state) {
	assert(decoder);
	

}


/* Fonctions Principales */
avr_inst_t *avr_decode(avr_decoder_t *decoder, avr_address_t address)
{
	avr_inst_t *res = 0;
	avr_ident_t id;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[32 / 32 + (32 % 32? 1: 0)];
	mask_t code;
	code.mask = i_buff;
	code.bit_length = 0;

	/* first, fetch the instruction at the given address */
	id = avr_fetch(decoder->fetch, address, &code);

	
	/* then decode it */
	res  = avr_decode_table[id](&code);
	res->addr = address;

	return res;
}



/* End of file avr_decode.c */
