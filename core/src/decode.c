/* Generated by gep (125/05/23 10:52:00) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <mos6502/fetch.h>
#include <mos6502/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <mos6502/config.h> /* for memory endiannesses */
#include <mos6502/gen_int.h>
#include "decode_table.h"

#define mos6502_error(e) fprintf(stderr, "%s\n", (e))


/* external functions */
mos6502_ident_t mos6502_fetch(mos6502_fetch_t *fetch, mos6502_address_t address, mask_t *code);


/* external tables */

/* decode structure */
struct mos6502_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
	mos6502_fetch_t *fetch;
};

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
mos6502_inst_t *mos6502_decode(mos6502_decoder_t *decoder, mos6502_address_t address);


/* initialization and destruction of mos6502_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder(mos6502_decoder_t *d, mos6502_platform_t *pf)
{
d->fetch = mos6502_new_fetch(pf);
}

static void halt_decoder(mos6502_decoder_t *d)
{
        mos6502_delete_fetch(d->fetch);
     
}

mos6502_decoder_t *mos6502_new_decoder(mos6502_platform_t *pf) {
	assert(pf);
    mos6502_decoder_t *res = malloc(sizeof(mos6502_decoder_t));
    if (res == NULL)
                mos6502_error("not enough memory to create a mos6502_decoder_t object"); /* I assume error handling will remain the same, we use mos6502_error istead of iss_error ? */
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void mos6502_delete_decoder(mos6502_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                mos6502_error("cannot delete an NULL mos6502_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
    
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void mos6502_set_cond_state(mos6502_decoder_t *decoder, mos6502_state_t *state) {
	assert(decoder);
	

}


/* Fonctions Principales */
mos6502_inst_t *mos6502_decode(mos6502_decoder_t *decoder, mos6502_address_t address)
{
	mos6502_inst_t *res = 0;
	mos6502_ident_t id;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[24 / 32 + (24 % 32? 1: 0)];
	mask_t code;
	code.mask = i_buff;
	code.bit_length = 0;

	/* first, fetch the instruction at the given address */
	id = mos6502_fetch(decoder->fetch, address, &code);

	
	/* then decode it */
	res  = mos6502_decode_table[id](&code);
	res->addr = address;

	return res;
}



/* End of file mos6502_decode.c */
