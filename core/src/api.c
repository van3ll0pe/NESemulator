/* Generated by gep (125/05/23 10:52:00) copyright (c) 2008 IRIT - UPS */

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <mos6502/api.h>
#include "platform.h"
#include <mos6502/env.h>
#include <mos6502/macros.h>
#include <mos6502/config.h>


static char *mos6502_string_ident[] = {
	"MOS6502_UNKNOWN",
	"MOS6502_JAM",
	"MOS6502_JAM_0",
	"MOS6502_JAM_1",
	"MOS6502_JAM_2",
	"MOS6502_JAM_3",
	"MOS6502_JAM_4",
	"MOS6502_JAM_5",
	"MOS6502_JAM_6",
	"MOS6502_JAM_7",
	"MOS6502_JAM_8",
	"MOS6502_JAM_9",
	"MOS6502_JAM_10",
	"MOS6502_IGN__242X__X",
	"MOS6502_IGN__242X__X_0",
	"MOS6502_IGN__242X__X_1",
	"MOS6502_IGN__242X__X_2",
	"MOS6502_IGN__242X__X_3",
	"MOS6502_IGN__242X__X_4",
	"MOS6502_IGN__242X",
	"MOS6502_IGN__242X_0",
	"MOS6502_IGN__242X_1",
	"MOS6502_IGN__242X2X__X",
	"MOS6502_IGN__242X2X__X_0",
	"MOS6502_IGN__242X2X__X_1",
	"MOS6502_IGN__242X2X__X_2",
	"MOS6502_IGN__242X2X__X_3",
	"MOS6502_IGN__242X2X__X_4",
	"MOS6502_IGN__242X2X",
	"MOS6502_SKB__I2X",
	"MOS6502_SKB__I2X_0",
	"MOS6502_SKB__I2X_1",
	"MOS6502_SKB__I2X_2",
	"MOS6502_SKB__I2X_3",
	"MOS6502_NOP",
	"MOS6502_NOP_0",
	"MOS6502_NOP_1",
	"MOS6502_NOP_2",
	"MOS6502_NOP_3",
	"MOS6502_NOP_4",
	"MOS6502_USBC__I2X",
	"MOS6502_SLO__LP__242X_RP___Y",
	"MOS6502_SLO__LP__242X__X_RP_",
	"MOS6502_SLO__242X2X__Y",
	"MOS6502_SLO__242X2X__X",
	"MOS6502_SLO__242X2X",
	"MOS6502_SLO__242X__X",
	"MOS6502_SLO__242X",
	"MOS6502_RLA__LP__242X_RP___Y",
	"MOS6502_RLA__LP__242X__X_RP_",
	"MOS6502_RLA__242X2X__Y",
	"MOS6502_RLA__242X2X__X",
	"MOS6502_RLA__242X2X",
	"MOS6502_RLA__242X__X",
	"MOS6502_RLA__242X",
	"MOS6502_RRA__LP__242X_RP__Y",
	"MOS6502_RRA__LP__242X_X_RP_",
	"MOS6502_RRA__242X2X__Y",
	"MOS6502_RRA__242X2X__X",
	"MOS6502_RRA__242X2X",
	"MOS6502_RRA__242X__X",
	"MOS6502_RRA__242X",
	"MOS6502_SRE__LP__242X_RP___Y",
	"MOS6502_SRE__LP__242X__X_RP_",
	"MOS6502_SRE__242X2X__Y",
	"MOS6502_SRE__242X2X__X",
	"MOS6502_SRE__242X2X",
	"MOS6502_SRE__242X__X",
	"MOS6502_SRE__242X",
	"MOS6502_ISC__LP__242X_RP___Y",
	"MOS6502_ISC__LP__242X__X_RP_",
	"MOS6502_ISC__242X2X__Y",
	"MOS6502_ISC__242X2X__X",
	"MOS6502_ISC__242X2X",
	"MOS6502_ISC__242X__X",
	"MOS6502_ISC__242X",
	"MOS6502_DCP__LP__242X_RP___Y",
	"MOS6502_DCP__LP__242X__X_RP_",
	"MOS6502_DCP__242X2X__Y",
	"MOS6502_DCP__242X2X__X",
	"MOS6502_DCP__242X2X",
	"MOS6502_DCP__242X__X",
	"MOS6502_DCP__242X",
	"MOS6502_SHA__LP__242X_RP___Y",
	"MOS6502_SHA__242X2X",
	"MOS6502_SHY__242X2X",
	"MOS6502_SHX__242X2X",
	"MOS6502_SAX__LP__242X__X_RP_",
	"MOS6502_SAX__242X2X",
	"MOS6502_SAX__242X__Y",
	"MOS6502_SAX__242X",
	"MOS6502_LAX__LP__242X_RP___Y",
	"MOS6502_LAX__LP__242X__X_RP_",
	"MOS6502_LAX__242X2X__Y",
	"MOS6502_LAX__242X2X",
	"MOS6502_LAX__242X__Y",
	"MOS6502_LAX__242X",
	"MOS6502_SBX__I2X",
	"MOS6502_ARR__I2X",
	"MOS6502_ANC2__I2X",
	"MOS6502_ANC__I2X",
	"MOS6502_ALR__I2X",
	"MOS6502_NOP_5",
	"MOS6502_BIT__242X",
	"MOS6502_BIT__242X2X",
	"MOS6502_RTS",
	"MOS6502_JSR__242X2X",
	"MOS6502_JMP__LP__242X2X_RP_",
	"MOS6502_JMP__242X2X",
	"MOS6502_BVS__I2X",
	"MOS6502_BVC__I2X",
	"MOS6502_BPL__I2X",
	"MOS6502_BNE__I2X",
	"MOS6502_BMI__I2X",
	"MOS6502_BEQ__I2X",
	"MOS6502_BCS__I2X",
	"MOS6502_BCC__I2X",
	"MOS6502_ROR__242X2X__X",
	"MOS6502_ROR__242X2X",
	"MOS6502_ROR__242X__X",
	"MOS6502_ROR__242X",
	"MOS6502_ROR_A",
	"MOS6502_ROL__242X2X",
	"MOS6502_ROL__242X2X_0",
	"MOS6502_ROL_2X__X",
	"MOS6502_ROL__242X",
	"MOS6502_ROL_A",
	"MOS6502_LSR__242X2X__X",
	"MOS6502_LSR__242X2X",
	"MOS6502_LSR__242X__X",
	"MOS6502_LSR__242X",
	"MOS6502_LSR_A",
	"MOS6502_ASL__242X2X__X",
	"MOS6502_ASL__242X2X",
	"MOS6502_ASL__242X__X",
	"MOS6502_ASL__242X",
	"MOS6502_ASL_A",
	"MOS6502_CPY__242X2X",
	"MOS6502_CPY__242X",
	"MOS6502_CPY__I2X",
	"MOS6502_CPX__242X2X",
	"MOS6502_CPX__242X",
	"MOS6502_CPX__I2X",
	"MOS6502_CMP__LP__242X_RP___Y",
	"MOS6502_CMP__LP__242X__X_RP_",
	"MOS6502_CMP__242X2X__Y",
	"MOS6502_CMP__242X2X__X",
	"MOS6502_CMP__242X2X",
	"MOS6502_CMP__242X__X",
	"MOS6502_CMP__242X",
	"MOS6502_CMP__I2X",
	"MOS6502_SBC__LP__242X_RP___Y",
	"MOS6502_SBC__LP__242X__X_RP_",
	"MOS6502_SBC__242X2X__Y",
	"MOS6502_SBC__242X2X__X",
	"MOS6502_SBC__242X2X",
	"MOS6502_SBC__242X__X",
	"MOS6502_SBC__242X",
	"MOS6502_SBC__I2X",
	"MOS6502_ADC__LP__242X_RP___Y",
	"MOS6502_ADC__LP__242X__X_RP_",
	"MOS6502_ADC__242X2X__Y",
	"MOS6502_ADC__242X2X__X",
	"MOS6502_ADC__242X2X",
	"MOS6502_ADC__242X__X",
	"MOS6502_ADC__242X",
	"MOS6502_ADC__ID",
	"MOS6502_DEC__242X2X__X",
	"MOS6502_DEC__242X2X",
	"MOS6502_DEC__242X__X",
	"MOS6502_DEC__242X",
	"MOS6502_INC__242X2X__X",
	"MOS6502_INC__242X2X",
	"MOS6502_INC__242X__X",
	"MOS6502_INC__242X",
	"MOS6502_DEY",
	"MOS6502_INY",
	"MOS6502_DEX",
	"MOS6502_INX",
	"MOS6502_EOR__LP__242X_RP___Y",
	"MOS6502_EOR__LP__242X__X_RP_",
	"MOS6502_EOR__242X2X__Y",
	"MOS6502_EOR__242X2X__X",
	"MOS6502_EOR__242X2X",
	"MOS6502_EOR__242X__X",
	"MOS6502_EOR__242X",
	"MOS6502_EOR__I2X",
	"MOS6502_ORA__LP__242X_RP___Y",
	"MOS6502_ORA__LP__242X__X_RP_",
	"MOS6502_ORA__242X2X__Y",
	"MOS6502_ORA__242X2X__X",
	"MOS6502_ORA__242X2X",
	"MOS6502_ORA__242X__X",
	"MOS6502_ORA__242X",
	"MOS6502_ORA__I2X",
	"MOS6502_AND__LP__242X_RP___Y",
	"MOS6502_AND__LP__242X__X_RP_",
	"MOS6502_AND__242X2X__Y",
	"MOS6502_AND__242X2X__X",
	"MOS6502_AND__242X2X",
	"MOS6502_AND__242X__X",
	"MOS6502_AND__242X",
	"MOS6502_AND__I2X",
	"MOS6502_SEI",
	"MOS6502_SEC",
	"MOS6502_SED",
	"MOS6502_CLV",
	"MOS6502_CLI",
	"MOS6502_CLD",
	"MOS6502_CLC",
	"MOS6502_PLP",
	"MOS6502_PHP",
	"MOS6502_PLA",
	"MOS6502_PHA",
	"MOS6502_TYA",
	"MOS6502_TXS",
	"MOS6502_TXA",
	"MOS6502_TSX",
	"MOS6502_TAY",
	"MOS6502_TAX",
	"MOS6502_STY__242X2X",
	"MOS6502_STY__242X__X",
	"MOS6502_STY__242X",
	"MOS6502_STX__242X2X",
	"MOS6502_STX__242X__Y",
	"MOS6502_STX__242X",
	"MOS6502_STA__LP__242X__X_RP_",
	"MOS6502_STA__LP__242X_RP___Y",
	"MOS6502_STA__242X2X__Y",
	"MOS6502_STA__242X2X__X",
	"MOS6502_STA__242X2X",
	"MOS6502_STA__242X__X",
	"MOS6502_STA__242X",
	"MOS6502_LDY__242X2X__X",
	"MOS6502_LDY__242X2X",
	"MOS6502_LDY__242X__X",
	"MOS6502_LDY__242X",
	"MOS6502_LDY__I2X",
	"MOS6502_LDX__242X2X__Y",
	"MOS6502_LDX__242X2X",
	"MOS6502_LDX__242X__Y",
	"MOS6502_LDX__242X",
	"MOS6502_LDX__I2X",
	"MOS6502_LDA__LP__242X_RP___Y",
	"MOS6502_LDA__LP__242X__X_RP_",
	"MOS6502_LDA__242X2X__Y",
	"MOS6502_LDA__242X2X__X",
	"MOS6502_LDA__242X2X",
	"MOS6502_LDA__242X__X",
	"MOS6502_LDA__242X",
	"MOS6502_LDA__I2X"
};

/* execution code table */
typedef void (*mos6502_code_function_t)(mos6502_state_t *, mos6502_inst_t *);
extern mos6502_code_function_t mos6502_code_table[];


char *mos6502_get_string_ident(mos6502_ident_t id)
{
	return mos6502_string_ident[id];
}

static unsigned long mos6502_size_ident[] = {
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	8,
	8,
	8,
	8,
	8,
	8,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	8,
	16,
	24,
	8,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	16,
	16,
	8,
	24,
	24,
	16,
	16,
	8,
	24,
	24,
	16,
	16,
	8,
	24,
	24,
	16,
	16,
	8,
	24,
	16,
	16,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	24,
	24,
	16,
	16,
	24,
	24,
	16,
	16,
	8,
	8,
	8,
	8,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	24,
	16,
	16,
	24,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	24,
	24,
	16,
	16,
	16,
	24,
	24,
	16,
	16,
	16,
	16,
	16,
	24,
	24,
	24,
	16,
	16,
	16
};

unsigned long mos6502_get_inst_size_from_id(mos6502_ident_t id) {
	return mos6502_size_ident[id];
}

unsigned long mos6502_get_inst_size(mos6502_inst_t* inst) {
	return mos6502_size_ident[inst->ident];
}

/**
 * @typedef mos6502_platform_t
 * This opaque type allows to represent an hardware and software platform.
 * It includes information about:
 * @li the hardware memories,
 * @li the module data (including system calls and interruption support).
 */


/**
 * Build a new platform for the platform mos6502.
 * @return	Created platform or null if there is no more memory (see errno).
 * @note To release the platform, use mos6502_unlock_platform().
 */
mos6502_platform_t *mos6502_new_platform(void) {
	mos6502_platform_t *pf;
	char *assert;

	/* allocation */
	pf = (mos6502_platform_t *)calloc(1, sizeof(mos6502_platform_t));
	if(pf == NULL) {
		errno = ENOMEM;
		return NULL;
	}
	/* the new platform is not locked yet */
	pf->usage = 0;

	/* other init */
	pf->sys_env = calloc(1, sizeof(mos6502_env_t));
	if(pf->sys_env == NULL) {
		errno = ENOMEM;
		free(pf);
		return NULL;
	}

	/* memory initialization */
	pf->mems.named.ram = mos6502_mem_new();
	if(pf->mems.named.ram == NULL) {
		free(pf->sys_env);
		free(pf);
		return NULL;
	}
	pf->mems.named.ppuram = mos6502_mem_new();
	if(pf->mems.named.ppuram == NULL) {
		free(pf->sys_env);
		free(pf);
		return NULL;
	}
	pf->mems.named.apuram = mos6502_mem_new();
	if(pf->mems.named.apuram == NULL) {
		free(pf->sys_env);
		free(pf);
		return NULL;
	}
	pf->mems.named.cartridge = mos6502_mem_new();
	if(pf->mems.named.cartridge == NULL) {
		free(pf->sys_env);
		free(pf);
		return NULL;
	}


	/* module initialization */
	MOS6502_MEM_INIT(pf);
	MOS6502_GRT_INIT(pf);
	MOS6502_ERROR_INIT(pf);
	MOS6502_GEN_INT_INIT(pf);
	MOS6502_ENV_INIT(pf);
	MOS6502_LOADER_INIT(pf);
	MOS6502_CODE_INIT(pf);


	/* assertion check */
	assert = getenv("GLISS_NDEBUG");
	if(assert != NULL && strcasecmp(assert, "yes") == 0)
		mos6502_assert_enable = 0;

	/* return platform */
	return pf;
}


/**
 * Get a memory in the platform.
 * @param platform	Platform to get memory from.
 * @param index		Index of the memory to get.
 * @return			Requested memory.
 */
mos6502_memory_t *mos6502_get_memory(mos6502_platform_t *platform, int index) {
	if (platform == NULL)
		return NULL;

	return platform->mems.array[index];
}


/**
 * return the system info (argc, argv ...), meaningless
 * if used when no program loaded
 * @param	platform	Platform to get system info from.
 * @return		Requested system info.
 */
mos6502_env_t *mos6502_get_sys_env(mos6502_platform_t *platform)
{
	if (platform == NULL)
		return NULL;

	return platform->sys_env;
}


/**
 * Ensure that the platform is not released before a matching
 * mos6502_platform_unlock() is performed.
 * @param platform	Platform to lock.
 */
void mos6502_lock_platform(mos6502_platform_t *platform) {
	if (platform == NULL)
		return;

	platform->usage++;
}


/**
 * Unlock the platform. If it the last lock on the platform,
 * the platform is freed.
 * @param platform	Platform to unlock.
 */
void mos6502_unlock_platform(mos6502_platform_t *platform) {
	if (platform == NULL)
		return;

	/* unlock */
	if(--platform->usage != 0)
		return;

	/* destroy the modules */
	MOS6502_MEM_DESTROY(platform);
	MOS6502_GRT_DESTROY(platform);
	MOS6502_ERROR_DESTROY(platform);
	MOS6502_GEN_INT_DESTROY(platform);
	MOS6502_ENV_DESTROY(platform);
	MOS6502_LOADER_DESTROY(platform);
	MOS6502_CODE_DESTROY(platform);


	/* free the memories */
	mos6502_mem_delete(platform->mems.named.ram);
	mos6502_mem_delete(platform->mems.named.ppuram);
	mos6502_mem_delete(platform->mems.named.apuram);
	mos6502_mem_delete(platform->mems.named.cartridge);


	/* free system info */
	free(platform->sys_env);

	/* free the platform */
	free(platform);
	platform = NULL;
}


/* state management function */


/**
 * Create a new initialized state depending on a given platform
 * @param	platform	the platform helping the simulation on the created state
 * @return			a new initialized state suitable for the given platform
 */
mos6502_state_t *mos6502_new_state(mos6502_platform_t *platform)
{
	mos6502_state_t *state;

	/* allocation */
	state = (mos6502_state_t *)malloc(sizeof(mos6502_state_t));
	if(state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* zeroing of all registers and memory references */
	memset(state, 0, sizeof(mos6502_state_t));

	/* creating platform */
	if(platform == NULL)
	{
		free(state);
		return NULL;
	}
	state->platform = platform;

	/* locking it */
	mos6502_lock_platform(state->platform);

	/* memory initialization */
	state->RAM = state->platform->mems.named.ram;
	state->PPURAM = state->platform->mems.named.ppuram;
	state->APURAM = state->platform->mems.named.apuram;
	state->CARTRIDGE = state->platform->mems.named.cartridge;

	/* proper state initialization (from the op init) */
	MOS6502_PC = ((uint16_t)(65532LU));
	MOS6502_SP = ((uint8_t)(255LU));
	MOS6502_A = ((uint8_t)(0));
	MOS6502_X = ((uint8_t)(0));
	MOS6502_Y = ((uint8_t)(0));
	MOS6502_SR = 36;
	MOS6502_CYCLE = 0;
	MOS6502_TOTAL_CYCLE = 0;
	MOS6502_IS_JAM = ((uint8_t)(0));


	/* PC initialization */
	state->PC = platform->entry;
#	ifdef MOS6502_INIT_PC
		MOS6502_INIT_PC
#	else
		state->PC = platform->entry;
#	endif


	/* system registers initialization (argv, envp...) */
	mos6502_registers_fill_env(platform->sys_env, state);

	return state;
}


/**
 * Delete a state
 * @param	state	the state to delete
 */
void mos6502_delete_state(mos6502_state_t *state)
{
	if (state == NULL)
		return;

	/* unlock the platform */
	mos6502_unlock_platform(state->platform);

	/* free the state */
	free(state);
	state = NULL;
}


/**
 * Return a copy of a given state, both state will share the same memory
 * and each new state's register will have the same value as in the given state.
 * the copied state may not be suitable for further simulation as the stack pointers
 * and similar address registers will be identical in two different states
 * sharing the same memory
 *
 * @param	state	the state to copy
 * @return		a fresh allocated copy (to be freed by the caller)
 */
mos6502_state_t *mos6502_copy_state(mos6502_state_t *state)
{
	int i;

	if (state == NULL)
		return NULL;

	/* allocate a new state */
	mos6502_state_t *new_state = (mos6502_state_t *)malloc(sizeof(mos6502_state_t));
	if(new_state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* copy the platform and lock it */
	/* !!WARNING!! is this needed? as we may not wish to simulate with this state */
	new_state->platform = state->platform;
	mos6502_lock_platform(new_state->platform);

	/* copy all the registers */
	new_state->Y = state->Y;
	new_state->total_cycle = state->total_cycle;
	new_state->SR = state->SR;
	new_state->is_jam = state->is_jam;
	new_state->A = state->A;
	new_state->SP = state->SP;
	new_state->cycle = state->cycle;
	new_state->X = state->X;
	new_state->PC = state->PC;

	/* copy the references to the memory */
	new_state->RAM = state->RAM;
	new_state->PPURAM = state->PPURAM;
	new_state->APURAM = state->APURAM;
	new_state->CARTRIDGE = state->CARTRIDGE;


	return new_state;
}


/**
 * Return a copy of a given state which will be intended for a further simulation,
 * both state will share the same memory
 * and each new state's register will have the same value as in the given state.
 *
 * TODO: we want to be able to simulate on this forked state
 * so we should really care about stack pointer and other address registers
 * used to write data in memory, these should have a different value
 * for each state created as we share the same memory
 *
 * @param	state	the state to fork
 * @return		a fresh allocated copy (to be freed by the caller)
 */
mos6502_state_t *mos6502_fork_state(mos6502_state_t *state)
{
	int i;

	if (state == NULL)
		return NULL;

	/* allocate a new state */
	mos6502_state_t *new_state = (mos6502_state_t *)malloc(sizeof(mos6502_state_t));
	if(new_state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* copy the platform and lock it */
	new_state->platform = state->platform;
	mos6502_lock_platform(new_state->platform);

	/* copy all the registers */
	new_state->Y = state->Y;
	new_state->total_cycle = state->total_cycle;
	new_state->SR = state->SR;
	new_state->is_jam = state->is_jam;
	new_state->A = state->A;
	new_state->SP = state->SP;
	new_state->cycle = state->cycle;
	new_state->X = state->X;
	new_state->PC = state->PC;

	/* copy the references to the memory */
	new_state->RAM = state->RAM;
	new_state->PPURAM = state->PPURAM;
	new_state->APURAM = state->APURAM;
	new_state->CARTRIDGE = state->CARTRIDGE;

}


/**
 * Dump all register values of a given state to the given output
 *
 * @param	state	the state whose registers we wish to dump
 * @param	out	the file to dump within, typically stderr or stdout
 */
void mos6502_dump_state(mos6502_state_t *state, FILE *out)
{
	int i;

	/* dump all the registers */
	fprintf(out, "Y = %02X\n", state->Y);
	fprintf(out, "total_cycle = %08X\n", state->total_cycle);
	fprintf(out, "SR = %02X\n", state->SR);
	fprintf(out, "is_jam = %02X\n", state->is_jam);
	fprintf(out, "A = %02X\n", state->A);
	fprintf(out, "SP = %02X\n", state->SP);
	fprintf(out, "cycle = %08X\n", state->cycle);
	fprintf(out, "X = %02X\n", state->X);
	fprintf(out, "PC = %04X\n", state->PC);

}


/**
 * Output the header of a CSV validation output.
 * @param out	File to output to.
 */
void mos6502_output_header_valid(FILE *out) {
	fputs("# PC", out);

	fputc('\n', out);
}


/**
 * Output the given state for validation. The first column is the address
 * of the current instruction and next ones are the register.
 * @param state		State to dump.
 * @param out		File to output to.
 */
void mos6502_output_state_valid(mos6502_state_t *state, FILE *out) {

#	define GLISS_GET_I(v)	fprintf(out, "\t%08x", (v))
#	define GLISS_GET_L(v)	fprintf(out, "\t%016llx", (v))

	fprintf(out, "%08x", state->PC);

	fputc('\n', out);
}


/**
 * return a reference (a pointer in fact) towards the platform of a given state
 *
 * @param	state	the state we want to access the platform
 * @return		the address of the platform of the given state
 */
mos6502_platform_t *mos6502_platform(mos6502_state_t *state)
{
	if (state == NULL)
		return NULL;

	/* return the platform */
	return state->platform;
}


/* simulation functions */


/**
 * Create a new simulator structure with the given state
 * @param	state	the state on which we intend to simulate
 * @param	start_addr	the beginning of the execution (useful for executables compiled with no _start symbol),
 *				if null we leave the PC in its previous state given by the loader
 * @param	exit_addr	the explicitly given last instruction address to simulate, if null we will stop running in another way
 */
mos6502_sim_t *mos6502_new_sim(mos6502_state_t *state, mos6502_address_t start_addr, mos6502_address_t exit_addr)
{
	mos6502_sim_t *sim;

	if (state == NULL)
		return NULL;

	/* allocate a new simulator */
	sim = (mos6502_sim_t *)malloc(sizeof(mos6502_sim_t));
	if(sim == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* link the state to the new simulator */
	sim->state = state;

	/* create a new decoder */
	sim->decoder = mos6502_new_decoder(mos6502_platform(state));
	if (sim->decoder == NULL)
		return NULL;
	sim->addr_exit = exit_addr;
	if (start_addr)
		sim->state->PC = start_addr;

	/* not ended at start */
	sim->ended = 0;
	return sim;
}


//======================================================================
#if !defined(MOS6502_TRACE_CACHE) && !defined(MOS6502_DTRACE_CACHE)

/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
mos6502_inst_t *mos6502_next_inst(mos6502_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */
	return mos6502_decode(sim->decoder, sim->state->PC);
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function mos6502_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void mos6502_step(mos6502_sim_t *sim)
{
	mos6502_inst_t*  inst;
	mos6502_state_t* state = sim->state;

	/* retrieving next instruction */
    inst = mos6502_decode(sim->decoder, state->PC);

	/* execute it */

	mos6502_code_table[inst->ident](state, inst);

#ifndef MOS6502_INF_DECODE_CACHE
#ifndef MOS6502_FIXED_DECODE_CACHE
#ifndef MOS6502_LRU_DECODE_CACHE
    /* finally free it */
	mos6502_free_inst(inst);
#endif
#endif
#endif

	/* ended ? */
	if(sim->addr_exit == state->PC)
		sim->ended = 1;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t mos6502_run_and_count_inst(mos6502_sim_t *sim)
{
	uint64_t i = 0;
    mos6502_state_t*   state     = sim->state;
    mos6502_decoder_t* decoder   = sim->decoder;
    mos6502_address_t  addr_exit = sim->addr_exit;
	mos6502_inst_t* inst;
	while(!sim->ended) {
		inst = mos6502_decode(decoder, state->PC);
		mos6502_code_table[inst->ident](state, inst);
#ifndef MOS6502_INF_DECODE_CACHE
#ifndef MOS6502_FIXED_DECODE_CACHE
#ifndef MOS6502_LRU_DECODE_CACHE
    /* finally free it */
	mos6502_free_inst(inst);
#endif
#endif
#endif
		i++;
		if(addr_exit == state->PC)
			sim->ended = 1;
	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void mos6502_run_sim(mos6502_sim_t *sim)
{
	mos6502_state_t*   state     = sim->state;
    mos6502_decoder_t* decoder   = sim->decoder;
    mos6502_address_t  addr_exit = sim->addr_exit;
	mos6502_inst_t* inst;
	while(!sim->ended) {
		inst = mos6502_decode(decoder, state->PC);
		mos6502_code_table[inst->ident](state, inst);
#ifndef MOS6502_INF_DECODE_CACHE
#ifndef MOS6502_FIXED_DECODE_CACHE
#ifndef MOS6502_LRU_DECODE_CACHE
    /* finally free it */
		mos6502_free_inst(inst);
#endif
#endif
#endif
		if(addr_exit == state->PC)
			sim->ended = 1;
	}
}
#endif
//======================================================================
#ifdef MOS6502_TRACE_CACHE
/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
mos6502_inst_t *mos6502_next_inst(mos6502_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */
	return mos6502_decode(sim->decoder, sim->state->PC) + ((sim->state->NIA >> 2) & (TRACE_DEPTH-1));
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function mos6502_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void mos6502_step(mos6502_sim_t *sim)
{
	mos6502_inst_t*  inst;
	mos6502_state_t* state = sim->state;

	/* retrieving next instruction */
    inst =  mos6502_decode(sim->decoder, state->PC) + ((sim->state->NIA >> 2) & (TRACE_DEPTH-1));

	/* execute it */

	mos6502_code_table[inst->ident](state, inst);

	/* ended ? */
	if(sim->addr_exit == state->PC)
		sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t mos6502_run_and_count_inst(mos6502_sim_t *sim)
{
	uint64_t i = 0;
    uint32_t num_bloc;
    mos6502_state_t*   state     = sim->state;
    mos6502_decoder_t* decoder   = sim->decoder;
    mos6502_address_t  addr_exit = sim->addr_exit;
    mos6502_inst_t*    inst, *trace;

	while(!sim->ended)
	{
        trace    = mos6502_decode(decoder, state->PC);
        num_bloc = (state->PC >> 2) >> TRACE_DEPTH_PW;

        while((((state->PC >> 2)>> TRACE_DEPTH_PW) == num_bloc) && (!sim->ended) && (addr_exit != state->PC))
        {
			inst = trace + ((state->NIA >> 2) & (TRACE_DEPTH-1));
			}
			i++;
		}

		/* ended ? */
		if(addr_exit == state->PC)
			sim->ended = 1;
	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void mos6502_run_sim(mos6502_sim_t *sim)
{
    uint32_t num_bloc;
    mos6502_state_t*   state     = sim->state;
    mos6502_decoder_t* decoder   = sim->decoder;
    mos6502_address_t  addr_exit = sim->addr_exit;
    mos6502_inst_t*    inst, *trace;

	while(addr_exit != state->PC)
	{
        trace    = mos6502_decode(decoder, state->PC);
        num_bloc = (state->PC >> 2) >> TRACE_DEPTH_PW;

        while((((state->PC >> 2)>> TRACE_DEPTH_PW) == num_bloc) && (addr_exit != state->PC))
        {
			inst = trace + ((state->NIA >> 2) & (TRACE_DEPTH-1));
		    mos6502_code_table[inst->ident](state, inst);
        }
	}
}
#endif
//======================================================================
#ifdef MOS6502_DTRACE_CACHE
/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
mos6502_inst_t *mos6502_next_inst(mos6502_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */

	/* Static variable is an optimisation hack
	 * in order to cache the current trace */
	static mos6502_inst_t*  inst = 0;
	mos6502_state_t* state = sim->state;

	/* retrieving next instruction */
	if(inst != 0)
	{
		inst++;
		if(inst->ident == -1)
			inst =  mos6502_decode(sim->decoder, state->PC);
	}else
	{
		inst =  mos6502_decode(sim->decoder, state->PC);
	}
	return inst;
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function mos6502_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void mos6502_step(mos6502_sim_t *sim)
{
	/* Static variable is an optimisation hack
	 * in order to cache the current trace */
	static mos6502_inst_t*  inst = 0;
	mos6502_state_t* state = sim->state;

	/* retrieving next instruction */
	if(inst != 0)
	{
		inst++;
		if(inst->ident == -1)
			inst =  mos6502_decode(sim->decoder, state->PC);
	}else
	{
		inst =  mos6502_decode(sim->decoder, state->PC);
	}


	/* execute it */

	mos6502_code_table[inst->ident](state, inst);

		if(sim->addr_exit == state->PC)
			sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t mos6502_run_and_count_inst(mos6502_sim_t *sim)
{
	uint64_t i = 0;
    mos6502_state_t*   state     = sim->state;
    mos6502_decoder_t* decoder   = sim->decoder;
    mos6502_address_t  addr_exit = sim->addr_exit;
    mos6502_inst_t*    inst;

	while(!sim->ended)
	{
        inst = mos6502_decode(decoder, state->PC);

        while( (inst->ident != -1) && (!sim->ended) && (addr_exit != state->PC))
        {
		    mos6502_code_table[inst->ident](state, inst);
			inst++;
			i++;
        }

        /* ended ? */
		if(addr_exit == state->PC)
			sim->ended = 1;

	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void mos6502_run_sim(mos6502_sim_t *sim)
{
    uint32_t num_bloc;
    mos6502_state_t*   state     = sim->state;
    mos6502_decoder_t* decoder   = sim->decoder;
    mos6502_address_t  addr_exit = sim->addr_exit;
    mos6502_inst_t*    inst;

	while(!sim->ended)
	{
        inst = mos6502_decode(decoder, state->PC);

        while( (inst->ident != -1) && (addr_exit != state->PC))
        {
		    mos6502_code_table[inst->ident](state, inst);
			inst++;
        }

        /* ended ? */
		if(addr_exit == state->PC)
			sim->ended = 1;
	}
}

#endif
//======================================================================
/**
 * @fn int mos6502_is_sim_ended(mos6502_sim_t *sim);
 * Indicate if the simulation is finished on the given simulator
 * @param	sim	the simulator which we simulate within
 * @return	whether or not the simulation is ended (0 => false, anything!=0 => true)
 */

/**
 * destruction of a simulator object, the associated state and decoder are also destroyed
 * @param	sim	the simulator to be deleted
 */
void mos6502_delete_sim(mos6502_sim_t *sim)
{
	if (sim == NULL)
		return;

	/* delete the decoder */
	mos6502_delete_decoder(sim->decoder);

	/* delete the state */
	mos6502_delete_state(sim->state);

	/* delete the sim */
	free(sim);
}


/**
 * Get the address of the next instruction to be executed,
 * indicated by PC
 * @param sim	Simulator to work with.
 * @return		Address of the current instruction.
 */
mos6502_address_t  mos6502_next_addr(mos6502_sim_t *sim) {
	assert(sim);
	return sim->state->PC;
}


/**
 * Set the address of the next instruction.
 * @param sim		Current simulator.
 * @param address	Next address.
 */
void mos6502_set_next_address(mos6502_sim_t *sim, mos6502_address_t address) {
	assert(sim);
	sim->state->PC = address;
}


/**
 * Set the exit address for simulation.
 * @param sim		Current simulator.
 * @param address	Exit address.
 */
void mos6502_set_exit_address(mos6502_sim_t *sim, mos6502_address_t address) {
	sim->addr_exit = address;
}


/**
 * Null-name ended list, provides the list of available decoding modes.
 */
mos6502_mode_t mos6502_modes[] = {
	{ "mos6502", mos6502_decode },
	{ 0, 0 }
};


/**
 * Boolean value indicating if assertion are tested are not.
 */
int mos6502_assert_enable = 1;


/**
 * Test the given assertion.
 * @param state	Current state.
 * @param cond	Condition of the assertion.
 * @param file	Source file of the assertion.
 * @param line	Source line of the assertion.
 */
void mos6502_assert(mos6502_state_t *state, int cond, const char *file, int line) {
	if(mos6502_assert_enable && !cond) {
		mos6502_dump_state(state, stderr);
		fprintf(stderr, "Assertion failure at %s:%d\n", file, line);
		abort();
	}
}


/****** convenience function only defined if a loader is available ******/

#ifdef MOS6502_LOADER_STATE
/**
 * Load the program from the given loader.
 * @param platform		Platform.
 * @param loader		Loader to get program from.
 */
void mos6502_load(mos6502_platform_t *platform, struct mos6502_loader_t *loader) {
	assert(platform);

	/* load in platform's memory */
	mos6502_loader_load(loader, platform);

	/* initialize system information */
	platform->entry = mos6502_loader_start(loader);
	mos6502_set_brk(platform, mos6502_brk_init(loader));

	/* !!TODO!! add argc,argv... init */
	/* stack initialization */
	mos6502_stack_fill_env(loader, platform, platform->sys_env);
}


/**
 * Load the given program in the platform and initialize stack
 * @param platform	Platform to load in.
 * @param path		Path of the file to load.
 * @return			0 for success, -1 for error (in errno).
 */
int mos6502_load_platform(mos6502_platform_t *platform, const char *path) {
	struct mos6502_loader_t *loader;
	assert(platform);

	/* open the file */
	loader = mos6502_loader_open(path);
	if(loader == NULL)
		return -1;

	/* load in platform's memory */
	mos6502_load(platform, loader);

	/* close the file */
	mos6502_loader_close(loader);

	/* return success */
	return 0;
}
#endif	/* MOS6502_LOADER_STATE */
