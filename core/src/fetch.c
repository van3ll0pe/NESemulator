/* Generated by gep (125/04/14 21:47:43) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <avr/mem.h>
#include <avr/fetch.h>
#include <avr/gen_int.h>
#include <avr/macros.h>
#include "fetch_table.h"

#define avr_error(e) fprintf(stderr, "%s\n", (e))


/**
 * Halt the fetch module.
 */
static void halt_fetch(void) {
}

/**
 * Initialize the fetch module.
 */
static void init_fetch(void) {
}



/**
 *  initialization and destruction of avr_fetch_t object
 */
static int number_of_fetch_objects = 0;


/**
 * Initialize a fetch handler.
 * @param pf	Current platform.
 * */
avr_fetch_t *avr_new_fetch(avr_platform_t *pf)
{
	avr_fetch_t *res = malloc(sizeof(avr_fetch_t));
	if (res == NULL)
		avr_error("not enough memory to create a avr_fetch_t object"); /* I assume error handling will remain the same, we use avr_error instead of iss_error ? */
	res->mem = avr_get_memory(pf, AVR_MAIN_MEMORY);
	if (number_of_fetch_objects == 0)
		init_fetch();
	number_of_fetch_objects++;
	return res;
}


/**
 * Delete the given fetch handler.
 * @param fetch		Fetch handler to delete.
 */
void avr_delete_fetch(avr_fetch_t *fetch)
{
	if (fetch == NULL)
		/* we shouldn't try to free a void fetch_t object, should this output an error ? */
		avr_error("cannot delete an NULL avr_fetch_t object");
	free(fetch);
	number_of_fetch_objects--;
	/*assert(number_of_fetch_objects >= 0);*/
	if (number_of_fetch_objects == 0)
		halt_fetch();
}


/**
 * Fetch and decode an instruction (for CISC instruction set).
 * @param fetch		Fetch handler.
 * @param address	Address of instruction to fetch.
 * @param code		Bytes to store instruction word in.
 * @return			Index of the fetched instruction.
 */
avr_ident_t avr_fetch(avr_fetch_t *fetch, avr_address_t address, mask_t *code) {
	uint32_t value;
	Table_Decodage_CISC *ptr;
	Table_Decodage_CISC *ptr2 =avr_table;

	do {
		
		/* if inst buffer has not enough bits to apply mask, read and add what's needed, read a 32 bit chunk (like in mask_t) at a time */
		while (get_mask_length(code) < get_mask_length(ptr2->mask)) {
			uint8_t buff[4];
			uint32_t word;
			avr_mem_read(fetch->mem, address + (get_mask_length(code) >> 3), buff, 4);
#			ifdef AVR_ORDER_BYTES_CISC
				AVR_ORDER_BYTES_CISC;
#			elif HOST_ENDIANNESS == TARGET_ENDIANNESS
				word = (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | buff[3];
#			endif
			set_mask_chunk(code, get_mask_length(code) >> 5, word);
			set_mask_length(code, get_mask_length(code) + 32);
		}

		/* compute value on mask */
		value = value_on_mask(code, ptr2->mask);
                ptr  = ptr2;
		ptr2 = ptr->table[value].ptr;

	} while (ptr->table[value].type == TABLEFETCH);

	return (avr_ident_t)ptr->table[value].ptr;
}



